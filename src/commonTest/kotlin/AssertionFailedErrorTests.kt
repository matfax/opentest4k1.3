/*
 * Copyright 2015-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.willowtreeapps.opentest4k

import kotlin.test.*

/**
 * Unit tests for [AssertionFailedError].
 *
 * @author Marc Philipp
 * @author Sam Brannen
 * @since 1.0
 */
class AssertionFailedErrorTests {

    @Test
    fun defaultConstructorDoesNotSetMessage() {
        assertNull(AssertionFailedError().message)
    }

    @Test
    fun nullMessageIsNotModified() {
        assertNull(AssertionFailedError(null).message)
        assertNull(AssertionFailedError(null, null).message)
        assertNull(AssertionFailedError(null, "foo", "bar").message)
        assertNull(AssertionFailedError(null, "foo", "bar", null).message)
    }

    @Test
    fun blankMessageIsNotModified() {
        assertEquals(BLANK, AssertionFailedError(BLANK).message)
        assertEquals(BLANK, AssertionFailedError(BLANK, null).message)
        assertEquals(BLANK, AssertionFailedError(BLANK, "foo", "bar").message)
        assertEquals(BLANK, AssertionFailedError(BLANK, "foo", "bar", null).message)
    }

    @Test
    fun toStringChecks() {
        val className = "${javaOnlyString("org.opentest4j.")}AssertionFailedError"
        assertEquals(className, AssertionFailedError().toString())
        assertEquals(className, AssertionFailedError(null).toString())
        assertEquals("$className: message", AssertionFailedError("message").toString())
    }

    @Test
    fun messageAndCauseAreStored() {
        val cause = RuntimeException("cause")

        val error = AssertionFailedError("my message", cause)

        assertEquals("my message", error.message)
        assertEquals(cause, error.cause)
        assertFalse(error.isExpectedDefined)
        assertFalse(error.isActualDefined)
    }

    @Test
    fun expectedAndActualValuesAreStored() {
        val errorWithExpectedAndActual = AssertionFailedError(null, "foo", "bar")
        assertTrue(errorWithExpectedAndActual.isExpectedDefined)
        assertEquals("foo", errorWithExpectedAndActual.expected?.value)
        assertTrue(errorWithExpectedAndActual.isActualDefined)
        assertEquals("bar", errorWithExpectedAndActual.actual?.value)
    }

    @Test
    fun returnsNullForExpectedAndActualWhenNotPassedToConstructor() {
        val errorWithoutExpectedAndActual = AssertionFailedError()
        assertFalse(errorWithoutExpectedAndActual.isExpectedDefined)
        assertNull(errorWithoutExpectedAndActual.expected)
        assertFalse(errorWithoutExpectedAndActual.isActualDefined)
        assertNull(errorWithoutExpectedAndActual.actual)
    }

    @Test
    fun serializationWorksForAssertionFailedErrorWithMessageAndExpectedAndActualValues() {
        val error = serializeAndDeserialize(AssertionFailedError("a message", "foo", "bar"))

        assertEquals("a message", error.message)
        assertTrue(error.isExpectedDefined)
        assertEquals("foo", error.expected?.value)
        assertTrue(error.isActualDefined)
        assertEquals("bar", error.actual?.value)
    }

    @Test
    fun serializationWorksForAssertionFailedErrorWithoutAnyValues() {
        val error = serializeAndDeserialize(AssertionFailedError())

        val e1 = AssertionError(null)
        println("e1 isNull: ${e1.message == null}")
        val e2 = Foo(null)
        println("e2 isNull: ${e2.message == null}")

        println("isNull: ${e2.message == null}")
        println("message: ${error.message}")
        println("isNull: ${error.message == null}")
        println("len: ${error.message?.length}")
        assertNull(error.message)
//        assertFalse(error.isExpectedDefined)
//        assertNull(error.expected)
//        assertFalse(error.isActualDefined)
//        assertNull(error.actual)
    }

}

class Foo(m: String?) : AssertionError(m)

private fun serializeAndDeserialize(originalError: AssertionFailedError): AssertionFailedError {
    val bytes = serialize(originalError)
    val deserializedObject: AssertionFailedError = deserialize(bytes)
    assertEquals(AssertionFailedError::class, deserializedObject::class)
    return deserializedObject
}

expect class Serialized

expect inline fun <reified T : Any> deserialize(bytes: Serialized): T

expect fun serialize(`object`: Any): Serialized

private const val BLANK = "   "
