/*
 * Copyright 2015-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
@file:Suppress("EXTENSION_SHADOWED_BY_MEMBER")

package com.willowtreeapps.opentest4k

import kotlin.reflect.KClass

/**
 * @author Marc Philipp
 * @author Sam Brannen
 */
actual class ValueWrapper
private constructor(val value: Any?) {
    val type: KClass<*>? = value?.let { it::class }
    val stringRepresentation: String = try {
        value.toString()
    } catch (e: Exception) {
        "<Exception in toString(): $e>"
    }
    val identityHashCode = value?.hashCode() ?: 0

    override fun toString(): String {
        return if (type == null) {
            "null"
        } else {
            "$stringRepresentation (${type.simpleName}@$identityHashCode)"
        }
    }

    companion object {
        private val nullValueWrapper = ValueWrapper(null)

        fun create(value: Any?): ValueWrapper {
            return if (value == null) nullValueWrapper else ValueWrapper(value)
        }
    }
}

actual fun Any?.toValueWrapper() = ValueWrapper.create(this)
actual inline val ValueWrapper.value: Any? get() = throw NotImplementedError()
actual inline val ValueWrapper.stringRepresentation: String get() = throw NotImplementedError()
actual inline val ValueWrapper.identityHashCode: Int get() = throw NotImplementedError()

/**
 * @author Sam Brannen
 * @author Marc Philipp
 */
actual open class AssertionFailedError : AssertionError {

    private val _cause: Throwable?
    val expected: ValueWrapper?
    val actual: ValueWrapper?

    actual constructor(message: String?, cause: Throwable?) : this(message, null, null, cause)

    actual constructor(message: String?, expected: Any?, actual: Any?, cause: Throwable?) : this(
        message,
        expected.toValueWrapper(),
        actual.toValueWrapper(),
        cause
    )

    private constructor(message: String?, expected: ValueWrapper?, actual: ValueWrapper?, cause: Throwable?) : super(
        message
    ) {
        this._cause = cause
        this.expected = expected
        this.actual = actual
    }

    override val cause: Throwable?
        get() = _cause

    val isExpectedDefined: Boolean get() = expected != null
    val isActualDefined: Boolean get() = actual != null

    override fun toString(): String {
        val builder = StringBuilder("AssertionFailedError")
        message?.let { message ->
            builder.append(": ").append(message)
        }
        return builder.toString()
    }
}

actual inline val AssertionFailedError.isExpectedDefined: Boolean get() = throw NotImplementedError()
actual inline val AssertionFailedError.isActualDefined: Boolean get() = throw NotImplementedError()
actual inline val AssertionFailedError.expected: ValueWrapper? get() = throw NotImplementedError()
actual inline val AssertionFailedError.actual: ValueWrapper? get() = throw NotImplementedError()

/**
 * @author Johannes Link
 * @author Sam Brannen
 * @author Marc Philipp
 */
actual open class MultipleFailuresError actual constructor(heading: String?, val failures: List<Throwable>) :
    AssertionError() {

    val heading: String = if (heading.isNullOrBlank()) "Multiple Failures" else heading!!

    override val message: String?
        get() {
            val failureCount = failures.size

            if (failureCount == 0) {
                return heading
            }

            // @formatter:off
            val builder = StringBuilder(heading)
                .append(" (")
                .append(failureCount).append(" ")
                .append(pluralize(failureCount, "failure", "failures"))
                .append(")\n")
            // @formatter:on

            val lastIndex = failureCount - 1
            for (failure in failures.subList(0, lastIndex)) {
                builder.append("\t").append(nullSafeMessage(failure)).append("\n")
            }
            builder.append('\t').append(nullSafeMessage(failures[lastIndex]))

            return builder.toString()
        }

    actual fun hasFailures(): Boolean = failures.isNotEmpty()
}

@Suppress("NOTHING_TO_INLINE")
private inline fun pluralize(count: Int, singular: String, plural: String): String =
    if (count == 1) singular else plural

private fun nullSafeMessage(failure: Throwable): String {
    if (failure.message.isNullOrBlank()) {
        return "<no message> in " + failure::class.name
    }
    return failure.message!!
}

actual inline val MultipleFailuresError.failures: List<Throwable> get() = throw NotImplementedError()

/**
 * @author Johannes Link
 * @author Sam Brannen
 */
actual open class IncompleteExecutionException actual constructor(message: String?, cause: Throwable?) :
    RuntimeException(message, cause)

/**
 * @author Sam Brannen
 * @author Johannes Link
 */
actual open class TestAbortedException actual constructor(message: String?, cause: Throwable?) :
    IncompleteExecutionException(message, cause)

/**
 * @author Sam Brannen
 * @author Johannes Link
 */
actual open class TestSkippedException actual constructor(message: String?, cause: Throwable?) :
    IncompleteExecutionException(message, cause)
